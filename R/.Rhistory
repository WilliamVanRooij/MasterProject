}
unlist_m_vb_g <- unlist(m_vb_g)
m_vb_g
unlist_m_vb_g <- mean(unlist(m_vb_g))[,1]
unlist_m_vb_g <- mean(unlist(m_vb_g))
unlist_m_vb_g
unlist_m_vb_g <- mean(unlist(m_vb_g))
unlist_m_vb_g <- (unlist(m_vb_g))
unlist_m_vb_g <- (unlist(m_vb_g))
unlist_m_vb_g <- mean(m_vb_g)
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:d0)
for(i in (0:9)){
sum <- sum + m_vb_g[[i]]
}
}
sum <- 0*(1:d0)
for(i in (0:9)){
sum <- sum + m_vb_g[[i]]
}
sum <- 0*(1:d)
sum <- 0*(1:p)
for(i in (0:9)){
sum <- sum + m_vb_g[[i]]
}
m_vb_g[[i]]
m_vb_g[[1]]
m_vb_g[[1]]+m_vb_g[[2]]
for(i in (0:9)){
#    sum <- sum + m_vb_g[[i]]
i
}
sum <- sum + m_vb_g[[i]]
plot(sum)
plot(sum(/10))
plot(sum/10
)
plot(sum/10)
?generate_dependence
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.95,
family = "gaussian", max_tot_pve = 0.8, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
# m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (0:9)){
sum <- sum + m_vb_g[[i]]
}
}
sum <- sum + m_vb_g[[0]]
sum <- sum + m_vb_g[[1]]
sum <- 0*(1:p)
# MAC
if(mac) {
cores <- detectCores()
# m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
}
plot(sum/10)
sum <- sum + m_vb_g[[i]]
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
?locus
n <- 200; p <- 250; p0 <- 25; d <- 1; d0 <- 1
gam_vb <- 0*c(1:p0);
cor_type <- "autocorrelated"; vec_rho <- runif(100, min = 0.25, max = 0.95)
nb_cpus <- 4; # Unfortunately, the number of cores available on Windows is only 1. But when computing on another computer, one can change the number of cpus used.
seed <- 123; set.seed(seed);
list_snps <- generate_snps(n, p, cor_type, vec_rho, n_cpus = nb_cpus,
user_seed = seed)
list_phenos <- generate_phenos(n, d, cor_type = cor_type, vec_rho = vec_rho,
n_cpus = nb_cpus, user_seed = seed)
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.95,
family = "gaussian", max_tot_pve = 0.8, block_phenos = TRUE, user_seed = seed)
cor_type <- "autocorrelated"; vec_rho <- runif(1, min = 0.25, max = 0.95)
nb_cpus <- 4; # Unfortunately, the number of cores available on Windows is only 1. But when computing on another computer, one can change the number of cpus used.
seed <- 123; set.seed(seed);
list_snps <- generate_snps(n, p, cor_type, vec_rho, n_cpus = nb_cpus,
user_seed = seed)
list_phenos <- generate_phenos(n, d, cor_type = cor_type, vec_rho = vec_rho,
n_cpus = nb_cpus, user_seed = seed)
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.95,
family = "gaussian", max_tot_pve = 0.8, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
params <- list(Y = dat_g$phenos, X = dat_g$snps, p0_av = p0, link = "identity");
mlocus <- function(fseed) {
vb_g <- locus(Y = params$Y, X=params$X, p0_av = params$p0_av, link = params$link, user_seed = fseed)
return(vb_g$gam_vb[,1])
}
mac = TRUE
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
# m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.95,
family = "gaussian", max_tot_pve = 0.2, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
params <- list(Y = dat_g$phenos, X = dat_g$snps, p0_av = p0, link = "identity");
mlocus <- function(fseed) {
vb_g <- locus(Y = params$Y, X=params$X, p0_av = params$p0_av, link = params$link, user_seed = fseed)
return(vb_g$gam_vb[,1])
}
mac = TRUE
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.95,
family = "gaussian", max_tot_pve = 1, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
params <- list(Y = dat_g$phenos, X = dat_g$snps, p0_av = p0, link = "identity");
mlocus <- function(fseed) {
vb_g <- locus(Y = params$Y, X=params$X, p0_av = params$p0_av, link = params$link, user_seed = fseed)
return(vb_g$gam_vb[,1])
}
mac = TRUE
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.95,
family = "gaussian", max_tot_pve = 0.99, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
params <- list(Y = dat_g$phenos, X = dat_g$snps, p0_av = p0, link = "identity");
mlocus <- function(fseed) {
vb_g <- locus(Y = params$Y, X=params$X, p0_av = params$p0_av, link = params$link, user_seed = fseed)
return(vb_g$gam_vb[,1])
}
mac = TRUE
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.99,
family = "gaussian", max_tot_pve = 0.99, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
params <- list(Y = dat_g$phenos, X = dat_g$snps, p0_av = p0, link = "identity");
mlocus <- function(fseed) {
vb_g <- locus(Y = params$Y, X=params$X, p0_av = params$p0_av, link = params$link, user_seed = fseed)
return(vb_g$gam_vb[,1])
}
mac = TRUE
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.01,
family = "gaussian", max_tot_pve = 0.99, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
params <- list(Y = dat_g$phenos, X = dat_g$snps, p0_av = p0, link = "identity");
mlocus <- function(fseed) {
vb_g <- locus(Y = params$Y, X=params$X, p0_av = params$p0_av, link = params$link, user_seed = fseed)
return(vb_g$gam_vb[,1])
}
mac = TRUE
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
?gener
?generate_dependence
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 4)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
n <- 200; p <- 1; p0 <- 1; d <- 500; d0 <- 400
gam_vb <- 0*c(1:p0);
cor_type <- "autocorrelated"; vec_rho <- runif(100, min = 0.25, max = 0.95)
nb_cpus <- 4; # Unfortunately, the number of cores available on Windows is only 1. But when computing on another computer, one can change the number of cpus used.
seed <- 123; set.seed(seed);
list_snps <- generate_snps(n, p, cor_type, vec_rho, n_cpus = nb_cpus,
user_seed = seed)
cor_type <- "autocorrelated"; vec_rho <- runif(100, min = 0.25, max = 0.95)
nb_cpus <- 4; # Unfortunately, the number of cores available on Windows is only 1. But when computing on another computer, one can change the number of cpus used.
seed <- 123; set.seed(seed);
list_snps <- generate_snps(n, p, cor_type, vec_rho[1], n_cpus = nb_cpus,
user_seed = seed)
list_phenos <- generate_phenos(n, d, cor_type = cor_type, vec_rho = vec_rho,
n_cpus = nb_cpus, user_seed = seed)
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.95,
family = "gaussian", max_tot_pve = 0.8, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
params <- list(Y = dat_g$phenos, X = dat_g$snps, p0_av = p0, link = "identity");
mlocus <- function(fseed) {
vb_g <- locus(Y = params$Y, X=params$X, p0_av = params$p0_av, link = params$link, user_seed = fseed)
return(vb_g$gam_vb[,1])
}
mac = TRUE
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
# m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
bars(sum/10)
plot(sum/10, tpy='bars')
plot(sum/10, tpy='bars')
plot(sum/10, type='bars')
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.05,
family = "gaussian", max_tot_pve = 0.8, block_phenos = TRUE, user_seed = seed)
# MAC
if(mac) {
cores <- detectCores()
# m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.05,
family = "gaussian", max_tot_pve = 0.8, block_phenos = TRUE, user_seed = seed)
# MAC
if(mac) {
cores <- detectCores()
# m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = cores)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = nb_cpus)
?mclapply
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 2)
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 2L)
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
n <- 200; p <- 1; p0 <- 1; d <- 500; d0 <- 400
gam_vb <- 0*c(1:p0);
cor_type <- "autocorrelated"; vec_rho <- runif(100, min = 0.25, max = 0.95)
nb_cpus <- 4; # Unfortunately, the number of cores available on Windows is only 1. But when computing on another computer, one can change the number of cpus used.
seed <- 123; set.seed(seed);
list_snps <- generate_snps(n, p, cor_type, vec_rho[1], n_cpus = nb_cpus,
user_seed = seed)
list_phenos <- generate_phenos(n, d, cor_type = cor_type, vec_rho = vec_rho,
n_cpus = nb_cpus, user_seed = seed)
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.05,
family = "gaussian", max_tot_pve = 0.8, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
params <- list(Y = dat_g$phenos, X = dat_g$snps, p0_av = p0, link = "identity");
mlocus <- function(fseed) {
vb_g <- locus(Y = params$Y, X=params$X, p0_av = params$p0_av, link = params$link, user_seed = fseed)
return(vb_g$gam_vb[,1])
}
mac = TRUE
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
n <- 200; p <- 100; p0 <- 100; d <- 500; d0 <- 400
?echoseq
?generate_dependence
n <- 200; p <- 100; p0 <- 100; d <- 500; d0 <- 400
gam_vb <- 0*c(1:p0);
cor_type <- "autocorrelated"; vec_rho <- runif(100, min = 0.25, max = 0.95)
nb_cpus <- 4; # Unfortunately, the number of cores available on Windows is only 1. But when computing on another computer, one can change the number of cpus used.
seed <- 123; set.seed(seed);
list_snps <- generate_snps(n, p, cor_type, vec_rho[1], n_cpus = nb_cpus,
user_seed = seed)
list_phenos <- generate_phenos(n, d, cor_type = cor_type, vec_rho = vec_rho,
n_cpus = nb_cpus, user_seed = seed)
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.05,
family = "gaussian", max_tot_pve = 0.8, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
params <- list(Y = dat_g$phenos, X = dat_g$snps, p0_av = p0, link = "identity");
mlocus <- function(fseed) {
vb_g <- locus(Y = params$Y, X=params$X, p0_av = params$p0_av, link = params$link, user_seed = fseed)
return(vb_g$gam_vb[,1])
}
mac = TRUE
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
n <- 200; p <- 100; p0 <- 10; d <- 500; d0 <- 400
gam_vb <- 0*c(1:p0);
cor_type <- "autocorrelated"; vec_rho <- runif(100, min = 0.25, max = 0.95)
nb_cpus <- 4; # Unfortunately, the number of cores available on Windows is only 1. But when computing on another computer, one can change the number of cpus used.
seed <- 123; set.seed(seed);
list_snps <- generate_snps(n, p, cor_type, vec_rho[1], n_cpus = nb_cpus,
user_seed = seed)
list_phenos <- generate_phenos(n, d, cor_type = cor_type, vec_rho = vec_rho,
n_cpus = nb_cpus, user_seed = seed)
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.05,
family = "gaussian", max_tot_pve = 0.8, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
params <- list(Y = dat_g$phenos, X = dat_g$snps, p0_av = p0, link = "identity");
mlocus <- function(fseed) {
vb_g <- locus(Y = params$Y, X=params$X, p0_av = params$p0_av, link = params$link, user_seed = fseed)
return(vb_g$gam_vb[,1])
}
mac = TRUE
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
dat_g <- generate_dependence(list_snps, list_phenos, ind_d0 = sample(1:d, d0),
ind_p0 = sample(1:p, p0), vec_prob_sh = 0.5,
family = "gaussian", max_tot_pve = 0.5, block_phenos = TRUE, user_seed = seed)
user_seed <- cbind(123,234,345,456,567,678,789,890,901,012)
params <- list(Y = dat_g$phenos, X = dat_g$snps, p0_av = p0, link = "identity");
mlocus <- function(fseed) {
vb_g <- locus(Y = params$Y, X=params$X, p0_av = params$p0_av, link = params$link, user_seed = fseed)
return(vb_g$gam_vb[,1])
}
mac = TRUE
if(!mac) {
cores <- detectCores()
cl <- makeCluster(cores)
mean(unlist(clusterApply(cl=cl,x=user_seed,fun=mlocus)))
}
# MAC
if(mac) {
cores <- detectCores()
m_vb_g <- mclapply(user_seed, mlocus, mc.cores = 1)
sum <- 0*(1:p)
for(i in (1:10)){
sum <- sum + m_vb_g[[i]]
}
plot(sum/10)
}
n <- 200; p <- 100; p0 <- 10; d <- 500; d0 <- 400
gam_vb <- 0*c(1:p0);
cor_type <- "autocorrelated";
vec_rho <- runif(100, min = 0.25, max = 0.95)
source('~/Documents/MasterProject/R/20190321_test_mlocus.R')
source('~/Documents/MasterProject/R/20190321_test_mlocus.R')
?generate_de
?generate_dependence
?lucs
?locus
?generate_snps
?locus
source('~/Documents/MasterProject/R/20190321_test_mlocus.R')
source('~/Documents/MasterProject/R/20190321_test_mlocus.R')
plot(sum/10)
source('~/Documents/MasterProject/R/20190321_test_mlocus.R')
source('~/Documents/MasterProject/R/20190321_test_mlocus.R')
source('~/Documents/MasterProject/R/20190321_test_mlocus.R')
source('~/Documents/MasterProject/R/20190321_test_mlocus.R')
source('~/Documents/MasterProject/R/20190321_test_mlocus.R')
Sys.info()['sysname']
